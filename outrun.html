<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Outrun Wallpaper</title>
  <style>
    @font-face {
      font-family: 'OutrunFuture';
      src: url('fonts/outrun_future.otf') format('opentype');
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background:
        linear-gradient(to bottom,
          transparent 0%,
          transparent 50%,
          rgba(138, 43, 226, 0.3) 50%,
          rgba(138, 43, 226, 0.6) 100%
        ),
        radial-gradient(circle at 50% 50%, #4c4d82 0%, #0b0d2a 80%);
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="outrunCanvas"></canvas>

  <script>
    const canvas = document.getElementById('outrunCanvas');
    const ctx = canvas.getContext('2d');
    let glow = 1;
    let rotationAngle = 0;
    const stars = [];
    const starCount = 100;
    const totalLines = 61;
    const horizontalLines = [];
    const lineSpawnInterval = 250
    const baseSpeed = 0.1;
    const acceleration = 0.05;

    let lastSpawn = 0;
    let lastFrameTime = 0;
    let wasPaused = false;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      stars.length = 0;
      generateStars();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function generateStars() {
      for (let i = 0; i < starCount; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 0.8 + 0.2,
          baseOpacity: Math.random() * 0.5 + 0.5,
          twinklePhase: Math.random() * Math.PI * 2,
          twinkleSpeed: Math.random() * 0.02 + 0.005
        });
      }
    }

    function drawStars() {
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(rotationAngle * 1);
      ctx.translate(-canvas.width / 2, -canvas.height / 2);
      stars.forEach(star => {
        star.twinklePhase += star.twinkleSpeed;
        const twinkle = Math.sin(star.twinklePhase) * 0.5 + 0.5;
        const opacity = star.baseOpacity * (0.2 + 0.8 * twinkle);
        ctx.beginPath();
        ctx.globalAlpha = opacity;
        ctx.fillStyle = '#ffffff';
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function drawSun() {
      const midY = canvas.height / 2;
      const sunRadius = canvas.width * 0.12;
      const sunX = canvas.width / 2;
      const sunY = midY - sunRadius * 0.425;

      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, canvas.width, midY);
      ctx.clip();

      ctx.shadowColor = '#ff6b9d';
      ctx.shadowBlur = 60 * glow;

      const gradient = ctx.createLinearGradient(sunX, sunY - sunRadius, sunX, sunY + sunRadius);
      gradient.addColorStop(0, '#ffff00');
      gradient.addColorStop(0.3, '#ff8c00');
      gradient.addColorStop(0.7, '#ff1493');
      gradient.addColorStop(1, '#ff6b9d');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawGroundBackground() {
      const midY = canvas.height / 2;
      const gradient = ctx.createRadialGradient(
        canvas.width / 2, midY, 0,
        canvas.width / 2, midY, canvas.width * 0.8
      );
      gradient.addColorStop(0, 'rgba(70, 35, 45, 1)');
      gradient.addColorStop(0.3, 'rgba(60, 25, 40, 1)');
      gradient.addColorStop(0.7, 'rgba(45, 20, 35, 1)');
      gradient.addColorStop(1, 'rgba(30, 15, 25, 1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, midY, canvas.width, canvas.height - midY);
    }

    function drawRoad() {
      const midY = canvas.height / 2;
      const centerIndex = Math.floor(totalLines / 2);
      const leftRoadIndex = centerIndex - 1;
      const rightRoadIndex = centerIndex + 1;
      const leftT = leftRoadIndex / (totalLines - 1);
      const rightT = rightRoadIndex / (totalLines - 1);
      const leftAdjustedT = 0.5 - 0.5 * Math.cos(Math.PI * leftT);
      const rightAdjustedT = 0.5 - 0.5 * Math.cos(Math.PI * rightT);
      const leftRoadHorizon = leftAdjustedT * canvas.width;
      const rightRoadHorizon = rightAdjustedT * canvas.width;
      const leftOffsetX = ((leftRoadHorizon - canvas.width / 2) / (canvas.width / 2)) * canvas.width * 5;
      const rightOffsetX = ((rightRoadHorizon - canvas.width / 2) / (canvas.width / 2)) * canvas.width * 5;
      const leftRoadBottom = leftRoadHorizon + leftOffsetX;
      const rightRoadBottom = rightRoadHorizon + rightOffsetX;
      const gradient = ctx.createLinearGradient(0, midY, 0, canvas.height);
      gradient.addColorStop(0, 'rgba(45, 50, 70, 1)');
      gradient.addColorStop(1, 'rgba(25, 30, 45, 1)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(leftRoadHorizon, midY);
      ctx.lineTo(rightRoadHorizon, midY);
      ctx.lineTo(rightRoadBottom, canvas.height);
      ctx.lineTo(leftRoadBottom, canvas.height);
      ctx.closePath();
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
      ctx.shadowBlur = 25 * glow;
      ctx.shadowColor = '#00ffff';
      ctx.beginPath();
      ctx.moveTo(leftRoadHorizon, midY);
      ctx.lineTo(leftRoadBottom, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(rightRoadHorizon, midY);
      ctx.lineTo(rightRoadBottom, canvas.height);
      ctx.stroke();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
      ctx.shadowBlur = 15 * glow;
      ctx.beginPath();
      ctx.moveTo(leftRoadHorizon, midY);
      ctx.lineTo(leftRoadBottom, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(rightRoadHorizon, midY);
      ctx.lineTo(rightRoadBottom, canvas.height);
      ctx.stroke();
      ctx.lineWidth = 1;
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#00ffff';
      ctx.beginPath();
      ctx.moveTo(leftRoadHorizon, midY);
      ctx.lineTo(leftRoadBottom, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(rightRoadHorizon, midY);
      ctx.lineTo(rightRoadBottom, canvas.height);
      ctx.stroke();
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(leftRoadHorizon, midY);
      ctx.lineTo(rightRoadHorizon, midY);
      ctx.lineTo(rightRoadBottom, canvas.height);
      ctx.lineTo(leftRoadBottom, canvas.height);
      ctx.closePath();
      ctx.clip();
      ctx.scale(1, -1);
      ctx.translate(0, -canvas.height);
      ctx.globalAlpha = 0.3;
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(rotationAngle * 1);
      ctx.translate(-canvas.width / 2, -canvas.height / 2);
      stars.forEach(star => {
        if (star.y < midY) {
          star.twinklePhase += star.twinkleSpeed;
          const twinkle = Math.sin(star.twinklePhase) * 0.5 + 0.5;
          const opacity = star.baseOpacity * (0.2 + 0.8 * twinkle);
          ctx.beginPath();
          ctx.globalAlpha = opacity * 0.3;
          ctx.fillStyle = '#ffffff';
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(1, -1);
      ctx.translate(0, -canvas.height);
      ctx.globalAlpha = 0.2;
      const sunX = canvas.width / 2;
      const sunRadius = canvas.width * 0.12;
      const sunY = midY - sunRadius * 0.425;
      if (sunY < midY) {
        ctx.shadowColor = '#ff6b9d';
        ctx.shadowBlur = 30;
        const gradient = ctx.createLinearGradient(sunX, sunY - sunRadius, sunX, sunY + sunRadius);
        gradient.addColorStop(0, '#ffff00');
        gradient.addColorStop(0.3, '#ff8c00');
        gradient.addColorStop(0.7, '#ff1493');
        gradient.addColorStop(1, '#ff6b9d');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
      const centerX = canvas.width / 2;
      const lineSpacing = 8;
      const leftCenterIndex = Math.floor(totalLines / 2) - 0.025;
      const rightCenterIndex = Math.floor(totalLines / 2) + 0.025;
      const leftCenterT = leftCenterIndex / (totalLines - 1);
      const leftCenterAdjustedT = 0.5 - 0.5 * Math.cos(Math.PI * leftCenterT);
      const leftCenterHorizon = leftCenterAdjustedT * canvas.width;
      const leftCenterOffsetX = ((leftCenterHorizon - canvas.width / 2) / (canvas.width / 2)) * canvas.width * 5;
      const rightCenterT = rightCenterIndex / (totalLines - 1);
      const rightCenterAdjustedT = 0.5 - 0.5 * Math.cos(Math.PI * rightCenterT);
      const rightCenterHorizon = rightCenterAdjustedT * canvas.width;
      const rightCenterOffsetX = ((rightCenterHorizon - canvas.width / 2) / (canvas.width / 2)) * canvas.width * 5;
      for (let y = midY; y < canvas.height; y += 2) {
        const yProgress = (y - midY) / (canvas.height - midY);
        const scalingFactor = Math.pow(yProgress, 0.5);
        const lineWidth = 0.8 + 5 * scalingFactor;
        const leftLineX = leftCenterHorizon + leftCenterOffsetX * yProgress;
        ctx.lineWidth = lineWidth + 2;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.shadowBlur = 8 * glow;
        ctx.shadowColor = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(leftLineX, y);
        ctx.lineTo(leftLineX, Math.min(y + 2, canvas.height));
        ctx.stroke();
        ctx.lineWidth = 0.5 + 3.5 * scalingFactor;
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(leftLineX, y);
        ctx.lineTo(leftLineX, Math.min(y + 2, canvas.height));
        ctx.stroke();
      }
      for (let y = midY; y < canvas.height; y += 2) {
        const yProgress = (y - midY) / (canvas.height - midY);
        const scalingFactor = Math.pow(yProgress, 0.5);
        const lineWidth = 0.8 + 5 * scalingFactor;
        const rightLineX = rightCenterHorizon + rightCenterOffsetX * yProgress;
        ctx.lineWidth = lineWidth + 2;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.shadowBlur = 8 * glow;
        ctx.shadowColor = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(rightLineX, y);
        ctx.lineTo(rightLineX, Math.min(y + 2, canvas.height));
        ctx.stroke();
        ctx.lineWidth = 0.5 + 3.5 * scalingFactor;
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(rightLineX, y);
        ctx.lineTo(rightLineX, Math.min(y + 2, canvas.height));
        ctx.stroke();
      }
    }

    function drawGrid() {
      const midY = canvas.height / 2;

      for (let i = 0; i < totalLines; i++) {
        const t = i / (totalLines - 1);
        const adjustedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
        const xMid = adjustedT * canvas.width;
        const offsetX = ((xMid - canvas.width / 2) / (canvas.width / 2)) * canvas.width * 5;

        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.08)';
        ctx.shadowBlur = 20 * glow;
        ctx.shadowColor = '#ff00ff';
        ctx.beginPath();
        ctx.moveTo(xMid, midY);
        ctx.lineTo(xMid + offsetX, canvas.height);
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.15)';
        ctx.shadowBlur = 10 * glow;
        ctx.beginPath();
        ctx.moveTo(xMid, midY);
        ctx.lineTo(xMid + offsetX, canvas.height);
        ctx.stroke();

        ctx.lineWidth = 1.5;
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(xMid, midY);
        ctx.lineTo(xMid + offsetX, canvas.height);
        ctx.stroke();
      }
    }

    function spawnHorizontalLine() {
      horizontalLines.push({ y: canvas.height / 2, speed: baseSpeed });
    }

    function updateHorizontalLines() {
      const midY = canvas.height / 2;
      horizontalLines.forEach(line => {
        const relativeDistance = (line.y - midY) / (canvas.height - midY);
        const speedMultiplier = 1 + Math.pow(relativeDistance, 2) * 3;
        line.y += line.speed * speedMultiplier;
        line.speed += acceleration;
      });
      for (let i = horizontalLines.length - 1; i >= 0; i--) {
        if (horizontalLines[i].y > canvas.height) horizontalLines.splice(i, 1);
      }
    }

    function drawHorizontalLines() {
      horizontalLines.forEach(line => {
        ctx.lineWidth = 6;
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.1)';
        ctx.shadowBlur = 40 * glow;
        ctx.shadowColor = '#ff00ff';
        ctx.beginPath();
        ctx.moveTo(0, line.y);
        ctx.lineTo(canvas.width, line.y);
        ctx.stroke();

        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.25)';
        ctx.shadowBlur = 20 * glow;
        ctx.beginPath();
        ctx.moveTo(0, line.y);
        ctx.lineTo(canvas.width, line.y);
        ctx.stroke();

        ctx.lineWidth = 1.5;
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(0, line.y);
        ctx.lineTo(canvas.width, line.y);
        ctx.stroke();
      });
    }

    function drawHorizon() {
      const midY = canvas.height / 2;

      ctx.lineWidth = 8;
      ctx.strokeStyle = 'rgba(255, 0, 255, 0.12)';
      ctx.shadowBlur = 30 * glow;
      ctx.shadowColor = '#ff00ff';
      ctx.beginPath();
      ctx.moveTo(0, midY);
      ctx.lineTo(canvas.width, midY);
      ctx.stroke();

      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(255, 0, 255, 0.25)';
      ctx.shadowBlur = 15 * glow;
      ctx.beginPath();
      ctx.moveTo(0, midY);
      ctx.lineTo(canvas.width, midY);
      ctx.stroke();

      ctx.lineWidth = 1.5;
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(0, midY);
      ctx.lineTo(canvas.width, midY);
      ctx.stroke();
    }

    function animate(timestamp) {

      if (lastFrameTime > 0 && timestamp - lastFrameTime > 100) {
        wasPaused = true;
      }

      if (wasPaused) {
        lastSpawn = timestamp;
        wasPaused = false;
      }
      
      if (!lastSpawn) lastSpawn = timestamp;
      
      const delta = timestamp - lastSpawn;
      
      if (delta > lineSpawnInterval && horizontalLines.length < 15) {
        spawnHorizontalLine();
        lastSpawn = timestamp;
      }

      rotationAngle += 0.0002;
      lastFrameTime = timestamp;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawStars();
      drawSun();
      drawGroundBackground();
      drawGrid();
      drawHorizon();
      updateHorizontalLines();
      drawHorizontalLines();
      drawRoad();

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
